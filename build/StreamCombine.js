// Generated by CoffeeScript 2.5.1
(function() {
  var Readable, StreamCombine, _;

  _ = require("underscore");

  ({Readable} = require("stream"));

  StreamCombine = class StreamCombine extends Readable {
    constructor(streams, key) {
      var i, index, len, ref, ref1, stream;
      super({
        objectMode: true
      });
      this.streams = streams;
      this.key = key;
      if (!this.streams) {
        throw new Error("Streams argument is required");
      }
      if (!Array.isArray(this.streams)) {
        throw new Error("Streams should be an Array");
      }
      if (!this.streams.length) {
        throw new Error("Streams array should not be empty");
      }
      if (this.key == null) {
        throw new Error("Key argument is required");
      }
      this.ended = (function() {
        var i, len, ref, results;
        ref = this.streams;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stream = ref[i];
          results.push(false);
        }
        return results;
      }).call(this);
      this.current = (function() {
        var i, len, ref, results;
        ref = this.streams;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stream = ref[i];
          results.push(null);
        }
        return results;
      }).call(this);
      this.indexes = (function() {
        var results = [];
        for (var i = 0, ref = this.streams.length; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
        return results;
      }).apply(this);
      this.busy = false;
      ref1 = this.streams;
      for (index = i = 0, len = ref1.length; i < len; index = ++i) {
        stream = ref1[index];
        ((stream, index) => {
          stream.on("error", (error) => {
            return this.emit("error", error);
          });
          stream.on("end", this.handleEnd.bind(this, index));
          return stream.on("data", this.handleData.bind(this, index));
        })(stream, index);
      }
    }

    _read() {
      if (this.busy) {
        return;
      }
      this.busy = true;
      return this.resumeStreams();
    }

    getLowestKeyIndexes() {
      var i, index, keys, len, object, ref, skip;
      keys = [];
      skip = false;
      ref = this.current;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        object = ref[index];
        if (object) {
          keys[index] = object[this.key];
        } else {
          if (this.ended[index]) {
            keys[index] = 2e308;
          } else {
            skip = true;
            break;
          }
        }
      }
      if (skip) {
        return [];
      }
      this.lowest = _.min(keys);
      return _.chain(this.current).map((object, index) => {
        if (object && object[this.key] === this.lowest) {
          return index;
        }
      }).filter(function(index) {
        return index != null;
      }).value();
    }

    resumeStreams() {
      var i, index, len, reEvaluatePush, ref;
      reEvaluatePush = false;
      ref = this.indexes;
      for (i = 0, len = ref.length; i < len; i++) {
        index = ref[i];
        this.current[index] = null;
        if (this.ended[index]) {
          if (!reEvaluatePush) {
            reEvaluatePush = true;
          }
        } else {
          this.streams[index].resume();
        }
      }
      if (reEvaluatePush) {
        return this.evaluatePush();
      }
    }

    evaluatePush() {
      var pushMore, send;
      this.indexes = this.getLowestKeyIndexes();
      if (!this.indexes.length) {
        return;
      }
      send = {
        data: _.map(this.indexes, (index) => {
          return this.current[index];
        }),
        indexes: this.indexes
      };
      send[this.key] = this.lowest;
      pushMore = this.push(send);
      if (!pushMore) {
        this.busy = false;
        return;
      }
      return this.resumeStreams();
    }

    handleData(index, object) {
      this.streams[index].pause();
      this.current[index] = object;
      return this.evaluatePush();
    }

    handleEnd(index) {
      this.ended[index] = true;
      this.evaluatePush();
      if (_.every(this.ended)) {
        return this.push(null);
      }
    }

  };

  module.exports = StreamCombine;

}).call(this);
